<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>tf::FlowBuilder class | Taskflow QuickStart</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://taskflow.github.io"><img src="taskflow_logo.png" alt="" />Taskflow</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">QuickStart</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Handbook</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="namespacetf.html">tf</a>::<wbr/></span>FlowBuilder <span class="m-thin">class</span>
        </h1>
        <p>class to build a task dependency graph</p>
        <nav class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              Reference
              <ul>
                <li><a href="#derived-classes">Derived classes</a></li>
                <li><a href="#typeless-methods">Constructors, destructors, conversion operators</a></li>
                <li><a href="#pub-methods">Public functions</a></li>
                <li><a href="#pro-attribs">Protected variables</a></li>
              </ul>
            </li>
          </ul>
        </nav>
<p>The class provides essential methods to construct a task dependency graph from which <a href="classtf_1_1Taskflow.html" class="m-doc">tf::<wbr />Taskflow</a> and <a href="classtf_1_1Subflow.html" class="m-doc">tf::<wbr />Subflow</a> are derived.</p>
        <section id="derived-classes">
          <h2><a href="#derived-classes">Derived classes</a></h2>
          <dl class="m-doc">
            <dt>
              class <a href="classtf_1_1Subflow.html" class="m-doc">Subflow</a>
            </dt>
            <dd>class to construct a subflow graph from the execution of a dynamic task</dd>
            <dt>
              class <a href="classtf_1_1Taskflow.html" class="m-doc">Taskflow</a>
            </dt>
            <dd>class to create a taskflow object</dd>
          </dl>
        </section>
        <section id="typeless-methods">
          <h2><a href="#typeless-methods">Constructors, destructors, conversion operators</a></h2>
          <dl class="m-doc">
            <dt id="a67d023d5493da1594a1d2eaea89da179">
              <span class="m-doc-wrap-bumper"><a href="#a67d023d5493da1594a1d2eaea89da179" class="m-doc-self">FlowBuilder</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1Graph.html" class="m-doc">Graph</a>&amp; graph)</span>
            </dt>
            <dd>constructs a flow builder with a graph</dd>
          </dl>
        </section>
        <section id="pub-methods">
          <h2><a href="#pub-methods">Public functions</a></h2>
          <dl class="m-doc">
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a11fc9c98eb3a0d3a9aa55598b1f4d614" class="m-doc">is_<wbr />static_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a static task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a1eea7593f25ab348cfb656dbdf4e5b05" class="m-doc">is_<wbr />dynamic_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a dynamic task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a00ca2fc2de0e679a7d9b8039340343df" class="m-doc">is_<wbr />condition_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a condition task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a78c40dc8776735b0f2c27cd446481aff" class="m-doc">is_<wbr />multi_<wbr />condition_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a multi-condition task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename... C, std::enable_if_t&lt;(sizeof...(C)&gt; 1&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a1f6118326ad434f6c839007a1a79fe1b" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C &amp;&amp; ... callables) -&gt; auto</span>
            </dt>
            <dd>creates multiple tasks from a list of callable objects</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a5627f7962099ac7c4986993cffa7b909" class="m-doc">erase</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1Task.html" class="m-doc">Task</a> task)</span>
            </dt>
            <dd>removes a task from a taskflow</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename T&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ac6f22228d4c2ea2e643c4b0d42c0e92a" class="m-doc">composed_of</a>(</span><span class="m-doc-wrap">T&amp; object) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a module task for the target object</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#acab0b4ac82260f47fdb36a3244ee3aaf" class="m-doc">placeholder</a>(</span><span class="m-doc-wrap">) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a placeholder task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0" class="m-doc">is_<wbr />cudaflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a cudaFlow task on the caller&#x27;s GPU device context</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, typename D, std::enable_if_t&lt;<a href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0" class="m-doc">is_<wbr />cudaflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#afdf47fd1a358fb64f8c1b89e2a393169" class="m-doc">emplace_on</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable,
              D&amp;&amp; device) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a cudaFlow task on the given device</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a574038aaa99e0220eedca4e8ea9389cf" class="m-doc">is_<wbr />syclflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a syclFlow task on the default queue</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, typename Q, std::enable_if_t&lt;<a href="namespacetf.html#a574038aaa99e0220eedca4e8ea9389cf" class="m-doc">is_<wbr />syclflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#af7c878fa6f0c4539ab88c0a85e6052d8" class="m-doc">emplace_on</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable,
              Q&amp;&amp; queue) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a syclFlow task on the given queue</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#af3d94f0be0f7b49e195c4e92737b1f85" class="m-doc">is_<wbr />runtime_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a runtime task</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a90f3d9b9d6fcf4df8e7d7878dfdd130d" class="m-doc">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/container/vector.html" class="m-doc-external">std::<wbr />vector</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt;&amp; tasks)</span>
            </dt>
            <dd>adds adjacent dependency links to a linear list of tasks</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a4ec89b554d15ad5fb96f4fdb10dbbb16" class="m-doc">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/utility/initializer_list.html" class="m-doc-external">std::<wbr />initializer_list</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt; tasks)</span>
            </dt>
            <dd>adds adjacent dependency links to a linear list of tasks</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ab405d7b10040530d8b04c11767b4960d" class="m-doc">for_each</a>(</span><span class="m-doc-wrap">B first,
              E last,
              C callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel-for task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename S, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a38ffe176bc3ae1827b9964322e3769d4" class="m-doc">for_each_index</a>(</span><span class="m-doc-wrap">B first,
              E last,
              S step,
              C callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a parallel-transform task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename O, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#abd813bd7afcbd8e6f56dc67883917d1a" class="m-doc">transform</a>(</span><span class="m-doc-wrap">B first1,
              E last1,
              O d_first,
              C c) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a parallel-transform task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B1, typename E1, typename B2, typename O, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#aa0b3271b34317710a1e32053a9abc3cf" class="m-doc">transform</a>(</span><span class="m-doc-wrap">B1 first1,
              E1 last1,
              B2 first2,
              O d_first,
              C c) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a parallel-transform task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename O&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#aa9494fe7b862fc832884ce318e8a37f5" class="m-doc">reduce</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; init,
              O bop) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel-reduce task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename BOP, typename UOP&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a024a1e5b4f138b6caebb427411fb0a2d" class="m-doc">transform_reduce</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; init,
              BOP bop,
              UOP uop) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel transform-reduce task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a35e180eb63de6c9f28e43185e837a4fa" class="m-doc">sort</a>(</span><span class="m-doc-wrap">B first,
              E last,
              C cmp) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a dynamic task to perform STL-styled parallel sort</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a7d844e9856c7c65b26ccdb83ffdab1d6" class="m-doc">sort</a>(</span><span class="m-doc-wrap">B first,
              E last) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a dynamic task to perform STL-styled parallel sort using the <code>std::less&lt;T&gt;</code> comparator, where <code>T</code> is the element type</dd>
          </dl>
        </section>
        <section id="pro-attribs">
          <h2><a href="#pro-attribs">Protected variables</a></h2>
          <dl class="m-doc">
            <dt id="a9404a57d9d37a4d49d20b686e4e5f68f">
              <a href="classtf_1_1Graph.html" class="m-doc">Graph</a>&amp; <a href="#a9404a57d9d37a4d49d20b686e4e5f68f" class="m-doc-self">_graph</a>
            </dt>
            <dd>associated graph object</dd>
          </dl>
        </section>
        <section>
          <h2>Function documentation</h2>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a11fc9c98eb3a0d3a9aa55598b1f4d614" class="m-doc">is_<wbr />static_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a static task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void()&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a static task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a static task.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">static_task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){});</span><span class="w"></span></pre><p>Please refer to <a href="StaticTasking.html" class="m-doc">Static Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a1eea7593f25ab348cfb656dbdf4e5b05" class="m-doc">is_<wbr />dynamic_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a dynamic task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void(tf::Subflow&amp;)&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a dynamic task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a dynamic task (<a href="classtf_1_1Subflow.html" class="m-doc">tf::<wbr />Subflow</a>) that spawns two static tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">dynamic_task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Subflow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sf</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">static_task1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sf</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){});</span><span class="w"></span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">static_task2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sf</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){});</span><span class="w"></span>
<span class="p">});</span><span class="w"></span></pre><p>Please refer to <a href="DynamicTasking.html" class="m-doc">Dynamic Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a00ca2fc2de0e679a7d9b8039340343df" class="m-doc">is_<wbr />condition_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a condition task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;int()&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a condition task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates an if-else block using one condition task and three static tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">taskflow</span><span class="p">;</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="n">cond</span><span class="p">,</span><span class="w"> </span><span class="n">yes</span><span class="p">,</span><span class="w"> </span><span class="n">no</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;yes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;no</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="c1">// executes yes if cond returns 0, or no if cond returns 1</span>
<span class="n">cond</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">yes</span><span class="p">,</span><span class="w"> </span><span class="n">no</span><span class="p">);</span><span class="w"></span>
<span class="n">cond</span><span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">init</span><span class="p">);</span><span class="w"></span></pre><p>Please refer to <a href="ConditionalTasking.html" class="m-doc">Conditional Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a78c40dc8776735b0f2c27cd446481aff" class="m-doc">is_<wbr />multi_<wbr />condition_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a multi-condition task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from <a href="http://en.cppreference.com/w/cpp/utility/functional/function.html" class="m-doc-external">std::<wbr />function</a>&lt;tf::SmallVector&lt;int&gt;()&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a multi-condition task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a multi-condition task that selectively jumps to two successor tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">taskflow</span><span class="p">;</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="n">cond</span><span class="p">,</span><span class="w"> </span><span class="n">branch1</span><span class="p">,</span><span class="w"> </span><span class="n">branch2</span><span class="p">,</span><span class="w"> </span><span class="n">branch3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">tf</span><span class="o">::</span><span class="n">SmallVector</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;branch1</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;branch2</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;branch3</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>

<span class="c1">// executes branch1 and branch3 when cond returns 0 and 2</span>
<span class="n">cond</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">branch1</span><span class="p">,</span><span class="w"> </span><span class="n">branch2</span><span class="p">,</span><span class="w"> </span><span class="n">branch3</span><span class="p">);</span><span class="w"></span>
<span class="n">cond</span><span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">init</span><span class="p">);</span><span class="w"></span></pre><p>Please refer to <a href="ConditionalTasking.html" class="m-doc">Conditional Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a1f6118326ad434f6c839007a1a79fe1b"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename... C, std::enable_if_t&lt;(sizeof...(C)&gt; 1&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a1f6118326ad434f6c839007a1a79fe1b" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C &amp;&amp; ... callables)</span></span>
            </h3>
            <p>creates multiple tasks from a list of callable objects</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable types</td>
                </tr>
                <tr>
                  <td>1</td>
                  <td></td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callables</td>
                  <td>one or multiple callable objects constructible from each task category</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The method returns a tuple of tasks each corresponding to the given callable target. You can use structured binding to get the return tasks one by one. The following example creates four static tasks and assign them to <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> using structured binding.</p><pre class="m-code"><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">);</span><span class="w"></span></pre>
          </div></section>
          <section class="m-doc-details" id="a5627f7962099ac7c4986993cffa7b909"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a5627f7962099ac7c4986993cffa7b909" class="m-doc-self">erase</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1Task.html" class="m-doc">Task</a> task)</span></span>
            </h3>
            <p>removes a task from a taskflow</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">task</td>
                  <td>task to remove</td>
                </tr>
              </tbody>
            </table>
<p>Removes a task and its input and output dependencies from the graph associated with the flow builder. If the task does not belong to the graph, nothing will happen.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">A</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">);</span><span class="w"></span>

<span class="c1">// erase A from the taskflow and its dependencies to B, C, and D</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">A</span><span class="p">);</span><span class="w"></span></pre>
          </div></section>
          <section class="m-doc-details" id="ac6f22228d4c2ea2e643c4b0d42c0e92a"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename T&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ac6f22228d4c2ea2e643c4b0d42c0e92a" class="m-doc-self">composed_of</a>(</span><span class="m-doc-wrap">T&amp; object)</span></span>
            </h3>
            <p>creates a module task for the target object</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">T</td>
                  <td>target object type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>object</td>
                  <td>a custom object that defines the method <code>T::graph()</code></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The example below demonstrates a taskflow composition using the <code>composed_of</code> method.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">;</span><span class="w"></span>
<span class="n">t1</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;t1&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>

<span class="c1">// t2 is partially composed of t1</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">comp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">composed_of</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;t2&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">init</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span><span class="w"></span></pre><p>The taskflow object <code>t2</code> is composed of another taskflow object <code>t1</code>, preceded by another static task <code>init</code>. When taskflow <code>t2</code> is submitted to an executor, <code>init</code> will run first and then <code>comp</code> which spwans its definition in taskflow <code>t1</code>.</p><p>The target <code>object</code> being composed must define the method <code>T::graph()</code> that returns a reference to a graph object of type <a href="classtf_1_1Graph.html" class="m-doc">tf::<wbr />Graph</a> such that it can interact with the executor. For example:</p><pre class="m-code"><span class="c1">// custom struct</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MyObj</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">Graph</span><span class="w"> </span><span class="n">graph</span><span class="p">;</span><span class="w"></span>
<span class="w">  </span><span class="n">MyObj</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tf</span><span class="o">::</span><span class="n">FlowBuilder</span><span class="w"> </span><span class="nf">builder</span><span class="p">(</span><span class="n">graph</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"></span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;a task</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w">  </span><span class="c1">// static task</span>
<span class="w">    </span><span class="p">});</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="n">Graph</span><span class="o">&amp;</span><span class="w"> </span><span class="n">graph</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">graph</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="n">MyObj</span><span class="w"> </span><span class="n">obj</span><span class="p">;</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">comp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">composed_of</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span><span class="w"></span></pre><p>Please refer to <a href="ComposableTasking.html" class="m-doc">Composable Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="acab0b4ac82260f47fdb36a3244ee3aaf"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#acab0b4ac82260f47fdb36a3244ee3aaf" class="m-doc-self">placeholder</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>creates a placeholder task</p>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>A placeholder task maps to a node in the taskflow graph, but it does not have any callable work assigned yet. A placeholder task is different from an empty task handle that does not point to any node in a graph.</p><pre class="m-code"><span class="c1">// create a placeholder task with no callable target assigned</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">placeholder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">placeholder</span><span class="p">();</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">placeholder</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">placeholder</span><span class="p">.</span><span class="n">has_work</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>

<span class="c1">// create an empty task handle</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">task</span><span class="p">;</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span><span class="w"></span>

<span class="c1">// assign the task handle to the placeholder task</span>
<span class="n">task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">placeholder</span><span class="p">;</span><span class="w"></span>
<span class="n">assert</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">task</span><span class="p">.</span><span class="n">has_work</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span></pre>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0" class="m-doc">is_<wbr />cudaflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a cudaFlow task on the caller&#x27;s GPU device context</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from <code>std::function&lt;void(tf::cudaFlow&amp;)&gt;</code></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>This method is equivalent to calling tf::FlowBuilder::emplace_on(callable, d) where <code>d</code> is the caller&#x27;s device context. The following example creates a cudaFlow of two kernel tasks, <code>task1</code> and <code>task2</code>, where <code>task1</code> runs before <code>task2</code>.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">cudaFlow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cf</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="c1">// create two kernel tasks</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span><span class="w"> </span><span class="n">task1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">grid1</span><span class="p">,</span><span class="w"> </span><span class="n">block1</span><span class="p">,</span><span class="w"> </span><span class="n">shm1</span><span class="p">,</span><span class="w"> </span><span class="n">kernel1</span><span class="p">,</span><span class="w"> </span><span class="n">args1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span><span class="w"> </span><span class="n">task2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">grid2</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="p">,</span><span class="w"> </span><span class="n">shm2</span><span class="p">,</span><span class="w"> </span><span class="n">kernel2</span><span class="p">,</span><span class="w"> </span><span class="n">args2</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// kernel1 runs before kernel2</span>
<span class="w">  </span><span class="n">task1</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">task2</span><span class="p">);</span><span class="w"></span>
<span class="p">});</span><span class="w"></span></pre><p>Please refer to <a href="GPUTaskingcudaFlow.html" class="m-doc">GPU Tasking (cudaFlow)</a> and <a href="GPUTaskingcudaFlowCapturer.html" class="m-doc">GPU Tasking (cudaFlowCapturer)</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="afdf47fd1a358fb64f8c1b89e2a393169"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, typename D, std::enable_if_t&lt;<a href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0" class="m-doc">is_<wbr />cudaflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#afdf47fd1a358fb64f8c1b89e2a393169" class="m-doc-self">emplace_on</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable,
              D&amp;&amp; device)</span></span>
            </h3>
            <p>creates a cudaFlow task on the given device</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void(tf::cudaFlow&amp;)&gt;</td>
                </tr>
                <tr>
                  <td>D</td>
                  <td>device type, either <code>int</code> or <code>std::ref&lt;int&gt;</code> (stateful)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a cudaFlow of two kernel tasks, <code>task1</code> and <code>task2</code> on GPU <code>2</code>, where <code>task1</code> runs before <code>task2</code></p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace_on</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">cudaFlow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cf</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="c1">// create two kernel tasks</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span><span class="w"> </span><span class="n">task1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">grid1</span><span class="p">,</span><span class="w"> </span><span class="n">block1</span><span class="p">,</span><span class="w"> </span><span class="n">shm1</span><span class="p">,</span><span class="w"> </span><span class="n">kernel1</span><span class="p">,</span><span class="w"> </span><span class="n">args1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span><span class="w"> </span><span class="n">task2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">grid2</span><span class="p">,</span><span class="w"> </span><span class="n">block2</span><span class="p">,</span><span class="w"> </span><span class="n">shm2</span><span class="p">,</span><span class="w"> </span><span class="n">kernel2</span><span class="p">,</span><span class="w"> </span><span class="n">args2</span><span class="p">);</span><span class="w"></span>

<span class="w">  </span><span class="c1">// kernel1 runs before kernel2</span>
<span class="w">  </span><span class="n">task1</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">task2</span><span class="p">);</span><span class="w"></span>
<span class="p">},</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span></pre>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a574038aaa99e0220eedca4e8ea9389cf" class="m-doc">is_<wbr />syclflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a syclFlow task on the default queue</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void(tf::syclFlow&amp;)&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>a callable that takes a referenced <a href="classtf_1_1syclFlow.html" class="m-doc">tf::<wbr />syclFlow</a> object</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a syclFlow on the default queue to submit two kernel tasks, <code>task1</code> and <code>task2</code>, where <code>task1</code> runs before <code>task2</code>.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">syclFlow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cf</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="c1">// create two single-thread kernel tasks</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">syclTask</span><span class="w"> </span><span class="n">task1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cf</span><span class="p">.</span><span class="n">single_task</span><span class="p">([](){});</span><span class="w"></span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">syclTask</span><span class="w"> </span><span class="n">task2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cf</span><span class="p">.</span><span class="n">single_task</span><span class="p">([](){});</span><span class="w"></span>

<span class="w">  </span><span class="c1">// kernel1 runs before kernel2</span>
<span class="w">  </span><span class="n">task1</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">task2</span><span class="p">);</span><span class="w"></span>
<span class="p">});</span><span class="w"></span></pre>
          </div></section>
          <section class="m-doc-details" id="af7c878fa6f0c4539ab88c0a85e6052d8"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, typename Q, std::enable_if_t&lt;<a href="namespacetf.html#a574038aaa99e0220eedca4e8ea9389cf" class="m-doc">is_<wbr />syclflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#af7c878fa6f0c4539ab88c0a85e6052d8" class="m-doc-self">emplace_on</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable,
              Q&amp;&amp; queue)</span></span>
            </h3>
            <p>creates a syclFlow task on the given queue</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void(tf::syclFlow&amp;)&gt;</td>
                </tr>
                <tr>
                  <td>Q</td>
                  <td>queue type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>a callable that takes a referenced <a href="classtf_1_1syclFlow.html" class="m-doc">tf::<wbr />syclFlow</a> object</td>
                </tr>
                <tr>
                  <td>queue</td>
                  <td>a queue of type sycl::queue</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a syclFlow on the given queue to submit two kernel tasks, <code>task1</code> and <code>task2</code>, where <code>task1</code> runs before <code>task2</code>.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace_on</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">syclFlow</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cf</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="c1">// create two single-thread kernel tasks</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">syclTask</span><span class="w"> </span><span class="n">task1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cf</span><span class="p">.</span><span class="n">single_task</span><span class="p">([](){});</span><span class="w"></span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">syclTask</span><span class="w"> </span><span class="n">task2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cf</span><span class="p">.</span><span class="n">single_task</span><span class="p">([](){});</span><span class="w"></span>

<span class="w">  </span><span class="c1">// kernel1 runs before kernel2</span>
<span class="w">  </span><span class="n">task1</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">task2</span><span class="p">);</span><span class="w"></span>
<span class="p">},</span><span class="w"> </span><span class="n">queue</span><span class="p">);</span><span class="w"></span></pre>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#af3d94f0be0f7b49e195c4e92737b1f85" class="m-doc">is_<wbr />runtime_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a runtime task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void(tf::Runtime&amp;)&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a runtime task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a runtime task that enables in-task control over the running executor.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">runtime_task</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span><span class="w"></span>
<span class="w">  </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">executor</span><span class="p">();</span><span class="w"></span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">num_workers</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span><span class="w"></span>
<span class="p">});</span><span class="w"></span></pre><p>Please refer to <a href="RuntimeTasking.html" class="m-doc">Runtime Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a90f3d9b9d6fcf4df8e7d7878dfdd130d"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a90f3d9b9d6fcf4df8e7d7878dfdd130d" class="m-doc-self">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/container/vector.html" class="m-doc-external">std::<wbr />vector</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt;&amp; tasks)</span></span>
            </h3>
            <p>adds adjacent dependency links to a linear list of tasks</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">tasks</td>
                  <td>a vector of tasks</td>
                </tr>
              </tbody>
            </table>
<p>This member function creates linear dependencies over a vector of tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tasks</span><span class="w"> </span><span class="p">{</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">}</span><span class="w"></span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">linearize</span><span class="p">(</span><span class="n">tasks</span><span class="p">);</span><span class="w">  </span><span class="c1">// A-&gt;B-&gt;C-&gt;D</span></pre>
          </div></section>
          <section class="m-doc-details" id="a4ec89b554d15ad5fb96f4fdb10dbbb16"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a4ec89b554d15ad5fb96f4fdb10dbbb16" class="m-doc-self">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/utility/initializer_list.html" class="m-doc-external">std::<wbr />initializer_list</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt; tasks)</span></span>
            </h3>
            <p>adds adjacent dependency links to a linear list of tasks</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">tasks</td>
                  <td>an initializer list of tasks</td>
                </tr>
              </tbody>
            </table>
<p>This member function creates linear dependencies over a list of tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;C&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;D&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">linearize</span><span class="p">({</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">});</span><span class="w">  </span><span class="c1">// A-&gt;B-&gt;C-&gt;D</span></pre>
          </div></section>
          <section class="m-doc-details" id="ab405d7b10040530d8b04c11767b4960d"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ab405d7b10040530d8b04c11767b4960d" class="m-doc-self">for_each</a>(</span><span class="m-doc-wrap">B first,
              E last,
              C callable)</span></span>
            </h3>
            <p>constructs a STL-styled parallel-for task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>a callable object to apply to the dereferenced iterator</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to each object obtained by dereferencing every iterator in the range <code>[first, last)</code>. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">itr</span><span class="o">=</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">!=</span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">callable</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>Arguments templated to enable stateful range using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take a single argument of the dereferenced iterator type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a38ffe176bc3ae1827b9964322e3769d4"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename S, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a38ffe176bc3ae1827b9964322e3769d4" class="m-doc-self">for_each_index</a>(</span><span class="m-doc-wrap">B first,
              E last,
              S step,
              C callable)</span></span>
            </h3>
            <p>constructs a parallel-transform task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning index type (must be integral)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending index type (must be integral)</td>
                </tr>
                <tr>
                  <td>S</td>
                  <td>step type (must be integral)</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>index of the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>index of the end (exclusive)</td>
                </tr>
                <tr>
                  <td>step</td>
                  <td>step size</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>a callable object to apply to each valid index</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to each index in the range <code>[first, last)</code> with the step size. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="c1">// case 1: step size is positive</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="n">step</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">callable</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// case 2: step size is negative</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">&gt;</span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">+=</span><span class="n">step</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">callable</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>Arguments are templated to enable stateful range using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take a single argument of the integral index type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="abd813bd7afcbd8e6f56dc67883917d1a"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename O, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#abd813bd7afcbd8e6f56dc67883917d1a" class="m-doc-self">transform</a>(</span><span class="m-doc-wrap">B first1,
              E last1,
              O d_first,
              C c)</span></span>
            </h3>
            <p>constructs a parallel-transform task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning input iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending input iterator type</td>
                </tr>
                <tr>
                  <td>O</td>
                  <td>output iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first1</td>
                  <td>iterator to the beginning of the first range</td>
                </tr>
                <tr>
                  <td>last1</td>
                  <td>iterator to the end of the first range</td>
                </tr>
                <tr>
                  <td>d_first</td>
                  <td>iterator to the beginning of the output range</td>
                </tr>
                <tr>
                  <td>c</td>
                  <td>an unary callable to apply to dereferenced input elements</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to an input range and stores the result in another output range. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">first1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">d_first</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="o">*</span><span class="n">first1</span><span class="o">++</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>Arguments are templated to enable stateful range using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take a single argument of the dereferenced iterator type.</p>
          </div></section>
          <section class="m-doc-details" id="aa0b3271b34317710a1e32053a9abc3cf"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B1, typename E1, typename B2, typename O, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aa0b3271b34317710a1e32053a9abc3cf" class="m-doc-self">transform</a>(</span><span class="m-doc-wrap">B1 first1,
              E1 last1,
              B2 first2,
              O d_first,
              C c)</span></span>
            </h3>
            <p>constructs a parallel-transform task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B1</td>
                  <td>beginning input iterator type for the first input range</td>
                </tr>
                <tr>
                  <td>E1</td>
                  <td>ending input iterator type for the first input range</td>
                </tr>
                <tr>
                  <td>B2</td>
                  <td>beginning input iterator type for the first second range</td>
                </tr>
                <tr>
                  <td>O</td>
                  <td>output iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first1</td>
                  <td>iterator to the beginning of the first input range</td>
                </tr>
                <tr>
                  <td>last1</td>
                  <td>iterator to the end of the first input range</td>
                </tr>
                <tr>
                  <td>first2</td>
                  <td>iterator to the beginning of the second input range</td>
                </tr>
                <tr>
                  <td>d_first</td>
                  <td>iterator to the beginning of the output range</td>
                </tr>
                <tr>
                  <td>c</td>
                  <td>a binary operator to apply to dereferenced input elements</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to two input ranges and stores the result in another output range. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">first1</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">last1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="o">*</span><span class="n">d_first</span><span class="o">++</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">(</span><span class="o">*</span><span class="n">first1</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">first2</span><span class="o">++</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>Arguments are templated to enable stateful range using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take two arguments of dereferenced elements from the two input ranges.</p>
          </div></section>
          <section class="m-doc-details" id="aa9494fe7b862fc832884ce318e8a37f5"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename O&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aa9494fe7b862fc832884ce318e8a37f5" class="m-doc-self">reduce</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; init,
              O bop)</span></span>
            </h3>
            <p>constructs a STL-styled parallel-reduce task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>O</td>
                  <td>binary reducer type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">itr</span><span class="o">=</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">!=</span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bop</span><span class="p">(</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">itr</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>Arguments are templated to enable stateful range using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a024a1e5b4f138b6caebb427411fb0a2d"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename BOP, typename UOP&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a024a1e5b4f138b6caebb427411fb0a2d" class="m-doc-self">transform_reduce</a>(</span><span class="m-doc-wrap">B first,
              E last,
              T&amp; init,
              BOP bop,
              UOP uop)</span></span>
            </h3>
            <p>constructs a STL-styled parallel transform-reduce task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>binary reducer type</td>
                </tr>
                <tr>
                  <td>UOP</td>
                  <td>unary transformion type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied in unspecified order to the results of <code>uop</code></td>
                </tr>
                <tr>
                  <td>uop</td>
                  <td>unary operator that will be applied to transform each element in the range to the result type</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the transformed elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">itr</span><span class="o">=</span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">!=</span><span class="n">last</span><span class="p">;</span><span class="w"> </span><span class="n">itr</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bop</span><span class="p">(</span><span class="n">init</span><span class="p">,</span><span class="w"> </span><span class="n">uop</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span></pre><p>Arguments are templated to enable stateful range using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a35e180eb63de6c9f28e43185e837a4fa"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a35e180eb63de6c9f28e43185e837a4fa" class="m-doc-self">sort</a>(</span><span class="m-doc-wrap">B first,
              E last,
              C cmp)</span></span>
            </h3>
            <p>constructs a dynamic task to perform STL-styled parallel sort</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type (random-accessible)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type (random-accessible)</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>comparator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>cmp</td>
                  <td>comparison function object</td>
                </tr>
              </tbody>
            </table>
<p>The task spawns a subflow to parallelly sort elements in the range <code>[first, last)</code>.</p><p>Arguments are templated to enable stateful range using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelSort.html" class="m-doc">Parallel Sort</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a7d844e9856c7c65b26ccdb83ffdab1d6"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a7d844e9856c7c65b26ccdb83ffdab1d6" class="m-doc-self">sort</a>(</span><span class="m-doc-wrap">B first,
              E last)</span></span>
            </h3>
            <p>constructs a dynamic task to perform STL-styled parallel sort using the <code>std::less&lt;T&gt;</code> comparator, where <code>T</code> is the element type</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type (random-accessible)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type (random-accessible)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
              </tbody>
            </table>
<p>The task spawns a subflow to parallelly sort elements in the range <code>[first, last)</code> using the <code>std::less&lt;T&gt;</code> comparator, where <code>T</code> is the dereferenced iterator type.</p><p>Arguments are templated to enable stateful range using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelSort.html" class="m-doc">Parallel Sort</a> for details.</p>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim">⌘</span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Taskflow handbook is part of the <a href="https://taskflow.github.io">Taskflow project</a>, copyright © <a href="https://tsung-wei-huang.github.io/">Dr. Tsung-Wei Huang</a>, 2018&ndash;2022.<br />Generated by <a href="https://doxygen.org/">Doxygen</a> 1.8.14 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
