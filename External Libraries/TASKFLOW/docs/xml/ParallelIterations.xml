<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="ParallelIterations" kind="page">
    <compoundname>ParallelIterations</compoundname>
    <title>Parallel Iterations</title>
    <tableofcontents/>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Taskflow provides template functions for constructing tasks to perform parallel iterations over ranges of items.</para><sect1 id="ParallelIterations_1A1IndexBasedParallelFor">
<title>Create an Index-based Parallel-Iteration Task</title>
<para>Index-based parallel-for performs parallel iterations over a range <computeroutput>[first, last)</computeroutput> with the given <computeroutput>step</computeroutput> size. The task created by <ref refid="classtf_1_1FlowBuilder_1a38ffe176bc3ae1827b9964322e3769d4" kindref="member">tf::Taskflow::for_each_index(B first, E last, S step, C callable)</ref> represents parallel execution of the following loop:</para><para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>positive<sp/>step</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first;<sp/>i&lt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>negative<sp/>step</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first;<sp/>i&gt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>We support only integer-based range. The range can go positive or negative direction.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a38ffe176bc3ae1827b9964322e3769d4" kindref="member">for_each_index</ref>(0,<sp/>100,<sp/><sp/>2,<sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>{<sp/>});<sp/><sp/></highlight><highlight class="comment">//<sp/>50<sp/>loops<sp/>with<sp/>a<sp/>+<sp/>step</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a38ffe176bc3ae1827b9964322e3769d4" kindref="member">for_each_index</ref>(100,<sp/>0,<sp/>-2,<sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>{<sp/>});<sp/><sp/></highlight><highlight class="comment">//<sp/>50<sp/>loops<sp/>with<sp/>a<sp/>-<sp/>step</highlight></codeline>
</programlisting></para><para>Notice that either positive or negative direction is defined in terms of the range, <computeroutput>[first, last)</computeroutput>, where <computeroutput>end</computeroutput> is excluded. In the positive case, the 50 items are 0, 2, 4, 6, 8, ..., 96, 98. In the negative case, the 50 items are 100, 98, 96, 04, ... 4, 2. An example of the Taskflow graph for the positive case under 12 workers is depicted below:</para><para><dotfile name="/home/twhuang/Code/taskflow/doxygen/images/parallel_for_1.dot"></dotfile>
</para><para>The index types, <computeroutput>B</computeroutput>, <computeroutput>E</computeroutput>, and <computeroutput>S</computeroutput>, are templates to preserve the variable types and their underlying types must be of the same <emphasis>integral</emphasis> type (e.g., <computeroutput>int</computeroutput>, <computeroutput>size_t</computeroutput>, <computeroutput>unsigned</computeroutput>). By default, <ref refid="classtf_1_1FlowBuilder_1a38ffe176bc3ae1827b9964322e3769d4" kindref="member">tf::Taskflow::for_each_index</ref> creates a task that spawns a subflow (see <ref refid="DynamicTasking" kindref="compound">Dynamic Tasking</ref>) to run iterations in parallel. The subflow closure captures all input arguments through perfect forwarding to form a stateful closure such that any changes on the arguments will be visible to the execution context of the subflow. For example:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>vec;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>first,<sp/>last;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>init<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>first<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>last<sp/><sp/>=<sp/>1000;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vec<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">[1000];<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>pf<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a38ffe176bc3ae1827b9964322e3769d4" kindref="member">for_each_index</ref>(std::ref(first),<sp/>std::ref(last),<sp/>1,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[&amp;]<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;parallel<sp/>iteration<sp/>on<sp/>index<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>vec[i]<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>wrong!<sp/>must<sp/>use<sp/>std::ref,<sp/>or<sp/>first<sp/>and<sp/>last<sp/>are<sp/>captured<sp/>by<sp/>copy</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>auto<sp/>pf<sp/>=<sp/>taskflow.for_each_index(first,<sp/>last,<sp/>1,<sp/>[&amp;](int<sp/>i)<sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;parallel<sp/>iteration<sp/>on<sp/>index<sp/>&quot;<sp/>&lt;&lt;<sp/>vec[i]<sp/>&lt;&lt;<sp/>&apos;\n&apos;;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>});</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">init.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(pf);</highlight></codeline>
</programlisting></para><para>When <computeroutput>init</computeroutput> finishes, the parallel-for task <computeroutput>pf</computeroutput> will see <computeroutput>first</computeroutput> as 0 and <computeroutput>last</computeroutput> as 1000 and performs parallel iterations over the 1000 items. This property is especially important for task graph parallelism, because users can define end-to-end parallelism through stateful closures that marshal parameter exchange between dependent tasks.</para></sect1>
<sect1 id="ParallelIterations_1A1IteratorBasedParallelFor">
<title>Create an Iterator-based Parallel-Iteration Task</title>
<para>Iterator-based parallel-for performs parallel iterations over a range specified by two <ulink url="https://en.cppreference.com/w/cpp/iterator/iterator">STL-styled iterators</ulink>, <computeroutput>first</computeroutput> and <computeroutput>last</computeroutput>. The task created by <ref refid="classtf_1_1FlowBuilder_1ab405d7b10040530d8b04c11767b4960d" kindref="member">tf::Taskflow::for_each(B first, E last, C callable)</ref> represents a parallel execution of the following loop:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first;<sp/>i&lt;last;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(*i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>By default, <ref refid="classtf_1_1FlowBuilder_1ab405d7b10040530d8b04c11767b4960d" kindref="member">tf::Taskflow::for_each(B first, E last, C callable)</ref> creates a task that spawns a subflow (see <ref refid="DynamicTasking" kindref="compound">Dynamic Tasking</ref>) that applies the callable to the object obtained by dereferencing every iterator in the range <computeroutput>[first, last)</computeroutput>. It is user&apos;s responsibility for ensuring the range is valid within the execution of the parallel-for task. Iterators must have the post-increment operator ++ defined. This version of parallel-for applies to all iterable STL containers.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>vec<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5};</highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1ab405d7b10040530d8b04c11767b4960d" kindref="member">for_each</ref>(vec.begin(),<sp/>vec.end(),<sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;parallel<sp/>for<sp/>on<sp/>item<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/list" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::list&lt;std::string&gt;</ref><sp/>list<sp/>=<sp/>{</highlight><highlight class="stringliteral">&quot;hi&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;from&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;t&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;a&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;s&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;k&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;f&quot;</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;low&quot;</highlight><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1ab405d7b10040530d8b04c11767b4960d" kindref="member">for_each</ref>(list.begin(),<sp/>list.end(),<sp/>[](</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="cpp/string/basic_string" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::string</ref>&amp;<sp/>str){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;parallel<sp/>for<sp/>on<sp/>item<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>str<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;<sp/><sp/></highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para><para>Similar to index-based parallel-for, the iterator types are templates to enable users to leverage the property of stateful closure. For example:</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>vec;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;::iterator</ref><sp/>first,<sp/>last;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>init<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>vec.resize(1000);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>first<sp/>=<sp/>vec.begin();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>last<sp/><sp/>=<sp/>vec.end();</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>pf<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1ab405d7b10040530d8b04c11767b4960d" kindref="member">for_each</ref>(std::ref(first),<sp/>std::ref(last),<sp/>[&amp;](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;parallel<sp/>iteration<sp/>on<sp/>item<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>wrong!<sp/>must<sp/>use<sp/>std::ref,<sp/>or<sp/>first<sp/>and<sp/>last<sp/>are<sp/>captured<sp/>by<sp/>copy</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>tf::Task<sp/>pf<sp/>=<sp/>taskflow.for_each(first,<sp/>last,<sp/>[&amp;](int<sp/>i)<sp/>{</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;parallel<sp/>iteration<sp/>on<sp/>item<sp/>&quot;<sp/>&lt;&lt;<sp/>i<sp/>&lt;&lt;<sp/>&apos;\n&apos;;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>});</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">init.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(pf);</highlight></codeline>
</programlisting></para><para>When <computeroutput>init</computeroutput> finishes, the parallel-for task <computeroutput>pf</computeroutput> will see <computeroutput>first</computeroutput> pointing to the beginning of <computeroutput>vec</computeroutput> and <computeroutput>last</computeroutput> pointing to the end of <computeroutput>vec</computeroutput> and performs parallel iterations over the 1000 items. The two tasks form an end-to-end task graph where the parameters of parallel-for are computed on the fly. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
