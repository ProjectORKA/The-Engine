<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="namespacetf" kind="namespace" language="C++">
    <compoundname>tf</compoundname>
    <innerclass refid="classtf_1_1ChromeObserver" prot="public">tf::ChromeObserver</innerclass>
    <innerclass refid="classtf_1_1CriticalSection" prot="public">tf::CriticalSection</innerclass>
    <innerclass refid="classtf_1_1cudaCapturingBase" prot="private">tf::cudaCapturingBase</innerclass>
    <innerclass refid="classtf_1_1cudaDeviceAllocator" prot="public">tf::cudaDeviceAllocator</innerclass>
    <innerclass refid="classtf_1_1cudaDeviceVector" prot="private">tf::cudaDeviceVector</innerclass>
    <innerclass refid="classtf_1_1cudaEvent" prot="public">tf::cudaEvent</innerclass>
    <innerclass refid="classtf_1_1cudaExecutionPolicy" prot="public">tf::cudaExecutionPolicy</innerclass>
    <innerclass refid="classtf_1_1cudaFlow" prot="public">tf::cudaFlow</innerclass>
    <innerclass refid="classtf_1_1cudaFlowCapturer" prot="public">tf::cudaFlowCapturer</innerclass>
    <innerclass refid="classtf_1_1cudaLinearCapturing" prot="public">tf::cudaLinearCapturing</innerclass>
    <innerclass refid="classtf_1_1cudaRoundRobinCapturing" prot="public">tf::cudaRoundRobinCapturing</innerclass>
    <innerclass refid="classtf_1_1cudaScopedDevice" prot="public">tf::cudaScopedDevice</innerclass>
    <innerclass refid="classtf_1_1cudaSequentialCapturing" prot="public">tf::cudaSequentialCapturing</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory" prot="private">tf::cudaSharedMemory</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01bool_01_4" prot="private">tf::cudaSharedMemory&lt; bool &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01char_01_4" prot="private">tf::cudaSharedMemory&lt; char &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01double_01_4" prot="private">tf::cudaSharedMemory&lt; double &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01float_01_4" prot="private">tf::cudaSharedMemory&lt; float &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01int_01_4" prot="private">tf::cudaSharedMemory&lt; int &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01long_01_4" prot="private">tf::cudaSharedMemory&lt; long &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01short_01_4" prot="private">tf::cudaSharedMemory&lt; short &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01char_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned char &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01int_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned int &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01long_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned long &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01short_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned short &gt;</innerclass>
    <innerclass refid="classtf_1_1cudaStream" prot="public">tf::cudaStream</innerclass>
    <innerclass refid="classtf_1_1cudaTask" prot="public">tf::cudaTask</innerclass>
    <innerclass refid="classtf_1_1cudaUSMAllocator" prot="public">tf::cudaUSMAllocator</innerclass>
    <innerclass refid="classtf_1_1CustomGraphBase" prot="private">tf::CustomGraphBase</innerclass>
    <innerclass refid="classtf_1_1Executor" prot="public">tf::Executor</innerclass>
    <innerclass refid="classtf_1_1FlowBuilder" prot="public">tf::FlowBuilder</innerclass>
    <innerclass refid="classtf_1_1Future" prot="public">tf::Future</innerclass>
    <innerclass refid="classtf_1_1Graph" prot="public">tf::Graph</innerclass>
    <innerclass refid="structtf_1_1IsPod" prot="private">tf::IsPod</innerclass>
    <innerclass refid="classtf_1_1Node" prot="private">tf::Node</innerclass>
    <innerclass refid="classtf_1_1ObserverInterface" prot="public">tf::ObserverInterface</innerclass>
    <innerclass refid="classtf_1_1Pipe" prot="public">tf::Pipe</innerclass>
    <innerclass refid="classtf_1_1Pipeflow" prot="public">tf::Pipeflow</innerclass>
    <innerclass refid="classtf_1_1Pipeline" prot="public">tf::Pipeline</innerclass>
    <innerclass refid="structtf_1_1ProfileData" prot="private">tf::ProfileData</innerclass>
    <innerclass refid="classtf_1_1Runtime" prot="public">tf::Runtime</innerclass>
    <innerclass refid="classtf_1_1ScalablePipeline" prot="public">tf::ScalablePipeline</innerclass>
    <innerclass refid="structtf_1_1Segment" prot="private">tf::Segment</innerclass>
    <innerclass refid="classtf_1_1Semaphore" prot="public">tf::Semaphore</innerclass>
    <innerclass refid="classtf_1_1SmallVector" prot="public">tf::SmallVector</innerclass>
    <innerclass refid="classtf_1_1SmallVectorBase" prot="private">tf::SmallVectorBase</innerclass>
    <innerclass refid="classtf_1_1SmallVectorImpl" prot="private">tf::SmallVectorImpl</innerclass>
    <innerclass refid="structtf_1_1SmallVectorStorage" prot="private">tf::SmallVectorStorage</innerclass>
    <innerclass refid="structtf_1_1SmallVectorStorage_3_01T_00_010_01_4" prot="private">tf::SmallVectorStorage&lt; T, 0 &gt;</innerclass>
    <innerclass refid="structtf_1_1SmallVectorStorage_3_01T_00_011_01_4" prot="private">tf::SmallVectorStorage&lt; T, 1 &gt;</innerclass>
    <innerclass refid="classtf_1_1SmallVectorTemplateBase" prot="private">tf::SmallVectorTemplateBase</innerclass>
    <innerclass refid="classtf_1_1SmallVectorTemplateBase_3_01T_00_01true_01_4" prot="private">tf::SmallVectorTemplateBase&lt; T, true &gt;</innerclass>
    <innerclass refid="classtf_1_1SmallVectorTemplateCommon" prot="private">tf::SmallVectorTemplateCommon</innerclass>
    <innerclass refid="classtf_1_1Subflow" prot="public">tf::Subflow</innerclass>
    <innerclass refid="classtf_1_1syclFlow" prot="public">tf::syclFlow</innerclass>
    <innerclass refid="classtf_1_1syclTask" prot="public">tf::syclTask</innerclass>
    <innerclass refid="classtf_1_1Task" prot="public">tf::Task</innerclass>
    <innerclass refid="classtf_1_1Taskflow" prot="public">tf::Taskflow</innerclass>
    <innerclass refid="classtf_1_1TaskView" prot="public">tf::TaskView</innerclass>
    <innerclass refid="classtf_1_1TFProfManager" prot="private">tf::TFProfManager</innerclass>
    <innerclass refid="classtf_1_1TFProfObserver" prot="public">tf::TFProfObserver</innerclass>
    <innerclass refid="structtf_1_1Timeline" prot="private">tf::Timeline</innerclass>
    <innerclass refid="classtf_1_1Worker" prot="public">tf::Worker</innerclass>
    <innerclass refid="classtf_1_1WorkerInterface" prot="public">tf::WorkerInterface</innerclass>
    <innerclass refid="classtf_1_1WorkerView" prot="public">tf::WorkerView</innerclass>
    <innernamespace refid="namespacetf_1_1detail">tf::detail</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacetf_1a1355048578785a80414707ff308b395a" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>TaskType</name>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842" prot="public">
          <name>PLACEHOLDER</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>placeholder task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa1fbe66e2b3b8907e5b1e605191a1c225" prot="public">
          <name>CUDAFLOW</name>
          <briefdescription>
<para><ref refid="classtf_1_1cudaFlow" kindref="compound">cudaFlow</ref> task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aaacf7c94171844e1799b1cccf0144938c" prot="public">
          <name>SYCLFLOW</name>
          <briefdescription>
<para><ref refid="classtf_1_1syclFlow" kindref="compound">syclFlow</ref> task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc" prot="public">
          <name>STATIC</name>
          <briefdescription>
<para>static task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa0fcc90da4811c877ba9f9c12f7d60bc9" prot="public">
          <name>DYNAMIC</name>
          <briefdescription>
<para>dynamic (subflow) task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac" prot="public">
          <name>CONDITION</name>
          <briefdescription>
<para>condition task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa2b3254ba9c686e11902551e79c8e1672" prot="public">
          <name>MULTI_CONDITION</name>
          <briefdescription>
<para>multi-condition task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69" prot="public">
          <name>MODULE</name>
          <briefdescription>
<para>module task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96" prot="public">
          <name>ASYNC</name>
          <briefdescription>
<para>asynchronous task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aae5f5cd9fe71ac064a678f27c7d539ae8" prot="public">
          <name>RUNTIME</name>
          <briefdescription>
<para>runtime task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa0db45d2a4141101bdfe48e3314cfbca3" prot="public">
          <name>UNDEFINED</name>
          <briefdescription>
<para>undefined task type (for internal use only) </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all task types </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" line="21" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" bodystart="21" bodyend="44"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435d" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>ObserverType</name>
        <enumvalue id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435dac19bf39d8838d00eddb556775fa8acce" prot="public">
          <name>TFPROF</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435da37960509766262569d504f02a0ee986d" prot="public">
          <name>CHROME</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435da0db45d2a4141101bdfe48e3314cfbca3" prot="public">
          <name>UNDEFINED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all observer types </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/observer.hpp" line="720" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/observer.hpp" bodystart="720" bodyend="724"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>PipeType</name>
        <enumvalue id="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564adf13a99b035d6f0bce4f44ab18eec8eb" prot="public">
          <name>PARALLEL</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>parallel type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" prot="public">
          <name>SERIAL</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>serial type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all pipe types </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/algorithm/pipeline.hpp" line="108" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/algorithm/pipeline.hpp" bodystart="108" bodyend="113"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132e" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>cudaTaskType</name>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132eaba2b45bdc11e2a4a6e86aab2ac693cbb" prot="public">
          <name>EMPTY</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>empty task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132eab9361011891280a44d85b967739cc6a5" prot="public">
          <name>HOST</name>
          <briefdescription>
<para>host task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132ea41d4dbfd78ceea21abb0ecb03c3cc921" prot="public">
          <name>MEMSET</name>
          <briefdescription>
<para>memory set task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132eac5d10cc70cce96265c445f14e7f5aba4" prot="public">
          <name>MEMCPY</name>
          <briefdescription>
<para>memory copy task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132ea35c10219c45ccfb5b07444fd7e17214c" prot="public">
          <name>KERNEL</name>
          <briefdescription>
<para>memory copy task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132ea46be697979903d784a70aeec45eb14ad" prot="public">
          <name>SUBFLOW</name>
          <briefdescription>
<para>subflow (child graph) task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132eab72f08e0732365cac9599b5c42157bf9" prot="public">
          <name>CAPTURE</name>
          <briefdescription>
<para>capture task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1afebc56ae6d5765010d0dd13a5f04132ea0db45d2a4141101bdfe48e3314cfbca3" prot="public">
          <name>UNDEFINED</name>
          <briefdescription>
<para>undefined task type </para>          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all cudaTask types </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_task.hpp" line="21" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_task.hpp" bodystart="21" bodyend="38"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacetf_1a8cff4bbd797dde4dfab096c3cc657833" prot="public" static="no">
        <type><ref refid="cpp/chrono/time_point" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::chrono::time_point</ref>&lt; <ref refid="cpp/chrono/steady_clock" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::chrono::steady_clock</ref> &gt;</type>
        <definition>using tf::observer_stamp_t = typedef std::chrono::time_point&lt;std::chrono::steady_clock&gt;</definition>
        <argsstring></argsstring>
        <name>observer_stamp_t</name>
        <briefdescription>
<para>default time point type of observers </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/observer.hpp" line="20" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/observer.hpp" bodystart="20" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetf_1aa18f102977c3257b75e21fde05efdb68" prot="public" static="no">
        <type><ref refid="classtf_1_1cudaExecutionPolicy" kindref="compound">cudaExecutionPolicy</ref>&lt; 512, 9 &gt;</type>
        <definition>using tf::cudaDefaultExecutionPolicy = typedef cudaExecutionPolicy&lt;512, 9&gt;</definition>
        <argsstring></argsstring>
        <name>cudaDefaultExecutionPolicy</name>
        <briefdescription>
<para>default execution policy </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_execution_policy.hpp" line="72" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_execution_policy.hpp" bodystart="72" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespacetf_1a6e7c9182ac3f60e339a7497c16633d28" prot="private" static="no" mutable="no">
        <type>ObjectPool&lt; Node &gt;</type>
        <definition>ObjectPool&lt;Node&gt; tf::node_pool</definition>
        <argsstring></argsstring>
        <name>node_pool</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/graph.hpp" line="465" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/graph.hpp" bodystart="465" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1ab74c19e0e6c9a4e3456dbae54ab9eed9" prot="private" static="no" mutable="no">
        <type>constexpr <ref refid="cpp/container/array" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array</ref>&lt; <ref refid="namespacetf_1a1355048578785a80414707ff308b395a" kindref="member">TaskType</ref>, 10 &gt;</type>
        <definition>constexpr std::array&lt;TaskType, 10&gt; tf::TASK_TYPES</definition>
        <argsstring></argsstring>
        <name>TASK_TYPES</name>
        <initializer>= {
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842" kindref="member">TaskType::PLACEHOLDER</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aa1fbe66e2b3b8907e5b1e605191a1c225" kindref="member">TaskType::CUDAFLOW</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aaacf7c94171844e1799b1cccf0144938c" kindref="member">TaskType::SYCLFLOW</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc" kindref="member">TaskType::STATIC</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aa0fcc90da4811c877ba9f9c12f7d60bc9" kindref="member">TaskType::DYNAMIC</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac" kindref="member">TaskType::CONDITION</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aa2b3254ba9c686e11902551e79c8e1672" kindref="member">TaskType::MULTI_CONDITION</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69" kindref="member">TaskType::MODULE</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96" kindref="member">TaskType::ASYNC</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aae5f5cd9fe71ac064a678f27c7d539ae8" kindref="member">TaskType::RUNTIME</ref>
}</initializer>
        <briefdescription>
<para>array of all task types (used for iterating task types) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" line="50" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" bodystart="50" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a11fc9c98eb3a0d3a9aa55598b1f4d614" prot="public" static="no" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_static_task_v</definition>
        <argsstring></argsstring>
        <name>is_static_task_v</name>
        <initializer>=
  std::is_invocable_r_v&lt;void, C&gt; &amp;&amp;
  !std::is_invocable_r_v&lt;int, C&gt; &amp;&amp;
  !std::is_invocable_r_v&lt;<ref refid="classtf_1_1SmallVector" kindref="compound">tf::SmallVector</ref>&lt;int&gt;, C&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a static task </para>        </briefdescription>
        <detaileddescription>
<para>A static task is a callable object constructible from std::function&lt;void()&gt;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" line="112" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" bodystart="112" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a1eea7593f25ab348cfb656dbdf4e5b05" prot="public" static="no" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_dynamic_task_v</definition>
        <argsstring></argsstring>
        <name>is_dynamic_task_v</name>
        <initializer>= std::is_invocable_r_v&lt;void, C, <ref refid="classtf_1_1Subflow" kindref="compound">Subflow</ref>&amp;&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a dynamic task </para>        </briefdescription>
        <detaileddescription>
<para>A dynamic task is a callable object constructible from std::function&lt;void(Subflow&amp;)&gt;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" line="123" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" bodystart="123" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a00ca2fc2de0e679a7d9b8039340343df" prot="public" static="no" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_condition_task_v</definition>
        <argsstring></argsstring>
        <name>is_condition_task_v</name>
        <initializer>= std::is_invocable_r_v&lt;int, C&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a condition task </para>        </briefdescription>
        <detaileddescription>
<para>A condition task is a callable object constructible from std::function&lt;int()&gt;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" line="131" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" bodystart="131" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a78c40dc8776735b0f2c27cd446481aff" prot="public" static="no" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_multi_condition_task_v</definition>
        <argsstring></argsstring>
        <name>is_multi_condition_task_v</name>
        <initializer>=
  std::is_invocable_r_v&lt;<ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt;int&gt;, C&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a multi-condition task </para>        </briefdescription>
        <detaileddescription>
<para>A multi-condition task is a callable object constructible from <ref refid="cpp/utility/functional/function" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::function</ref>&lt;tf::SmallVector&lt;int&gt;()&gt;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" line="140" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" bodystart="140" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1adb8433555d8cdc0b3c5d95e8d51a90f0" prot="public" static="no" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_cudaflow_task_v</definition>
        <argsstring></argsstring>
        <name>is_cudaflow_task_v</name>
        <initializer>= std::is_invocable_r_v&lt;void, C, <ref refid="classtf_1_1cudaFlow" kindref="compound">cudaFlow</ref>&amp;&gt; ||
                                    std::is_invocable_r_v&lt;void, C, <ref refid="classtf_1_1cudaFlowCapturer" kindref="compound">cudaFlowCapturer</ref>&amp;&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a cudaFlow task </para>        </briefdescription>
        <detaileddescription>
<para>A <ref refid="classtf_1_1cudaFlow" kindref="compound">cudaFlow</ref> task is a callable object constructible from std::function&lt;void(tf::cudaFlow&amp;)&gt; or std::function&lt;void(tf::cudaFlowCapturer&amp;)&gt;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" line="150" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" bodystart="150" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a574038aaa99e0220eedca4e8ea9389cf" prot="public" static="no" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_syclflow_task_v</definition>
        <argsstring></argsstring>
        <name>is_syclflow_task_v</name>
        <initializer>= std::is_invocable_r_v&lt;void, C, <ref refid="classtf_1_1syclFlow" kindref="compound">syclFlow</ref>&amp;&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a syclFlow task </para>        </briefdescription>
        <detaileddescription>
<para>A <ref refid="classtf_1_1syclFlow" kindref="compound">syclFlow</ref> task is a callable object constructible from std::function&lt;void(tf::syclFlow&amp;)&gt;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" line="160" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" bodystart="160" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1af3d94f0be0f7b49e195c4e92737b1f85" prot="public" static="no" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_runtime_task_v</definition>
        <argsstring></argsstring>
        <name>is_runtime_task_v</name>
        <initializer>= std::is_invocable_r_v&lt;void, C, <ref refid="classtf_1_1Runtime" kindref="compound">Runtime</ref>&amp;&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a runtime task </para>        </briefdescription>
        <detaileddescription>
<para>A runtime task is a callable object constructible from std::function&lt;void(tf::Runtime&amp;)&gt;. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" line="169" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" bodystart="169" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacetf_1aea9fe5c87d4439816239b5af6ebeec55" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>unsigned</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>static size_t tf::capacity_in_bytes</definition>
        <argsstring>(const SmallVector&lt; T, N &gt; &amp;X)</argsstring>
        <name>capacity_in_bytes</name>
        <param>
          <type>const <ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt; T, N &gt; &amp;</type>
          <declname>X</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/utility/small_vector.hpp" line="1018" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/utility/small_vector.hpp" bodystart="1018" bodyend="1020"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a9ca58dc6c666698cc7373eb0262140ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const char *</type>
        <definition>const char* tf::to_string</definition>
        <argsstring>(TaskType type)</argsstring>
        <name>to_string</name>
        <param>
          <type><ref refid="namespacetf_1a1355048578785a80414707ff308b395a" kindref="member">TaskType</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>convert a task type to a human-readable string </para>        </briefdescription>
        <detaileddescription>
<para>The name of each task type is the litte-case string of its characters.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842" kindref="member">TaskType::PLACEHOLDER</ref><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;placeholder&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aa1fbe66e2b3b8907e5b1e605191a1c225" kindref="member">TaskType::CUDAFLOW</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;cudaflow&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aaacf7c94171844e1799b1cccf0144938c" kindref="member">TaskType::SYCLFLOW</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;syclflow&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc" kindref="member">TaskType::STATIC</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;static&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aa0fcc90da4811c877ba9f9c12f7d60bc9" kindref="member">TaskType::DYNAMIC</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;subflow&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac" kindref="member">TaskType::CONDITION</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;condition&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aa2b3254ba9c686e11902551e79c8e1672" kindref="member">TaskType::MULTI_CONDITION</ref><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;multi_condition&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69" kindref="member">TaskType::MODULE</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;module&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96" kindref="member">TaskType::ASYNC</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;async&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="namespacetf_1a1355048578785a80414707ff308b395aae5f5cd9fe71ac064a678f27c7d539ae8" kindref="member">TaskType::RUNTIME</ref><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>-&gt;<sp/><sp/></highlight><highlight class="stringliteral">&quot;runtime&quot;</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" line="81" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" bodystart="81" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ad216aea4d0f648e149e47374ad015b1f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
        <definition>std::ostream&amp; tf::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Task &amp;task)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classtf_1_1Task" kindref="compound">Task</ref> &amp;</type>
          <declname>task</declname>
        </param>
        <briefdescription>
<para>overload of ostream inserter operator for <ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" line="626" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/task.hpp" bodystart="626" bodyend="629"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aa3fc0699b2c2b8f2f76bb39f91be1acb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const char *</type>
        <definition>const char* tf::to_string</definition>
        <argsstring>(ObserverType type)</argsstring>
        <name>to_string</name>
        <param>
          <type><ref refid="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435d" kindref="member">ObserverType</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>convert an observer type to a human-readable string </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/observer.hpp" line="729" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/observer.hpp" bodystart="729" bodyend="735"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abffa70155a5f160b7ceb86ee52ab2136" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_num_devices</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_num_devices</name>
        <briefdescription>
<para>queries the number of available devices </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="15" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="15" bodyend="19"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a235f5a9ce203d538eec1f4114221d473" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_device</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_device</name>
        <briefdescription>
<para>gets the current device associated with the caller thread </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="24" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="24" bodyend="28"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ade2938289fa49aafc9b2b7b090deaa22" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_set_device</definition>
        <argsstring>(int id)</argsstring>
        <name>cuda_set_device</name>
        <param>
          <type>int</type>
          <declname>id</declname>
        </param>
        <briefdescription>
<para>switches to a given device context </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="33" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="33" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a403b679694f4c85c857163b47e84d566" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_get_device_property</definition>
        <argsstring>(int i, cudaDeviceProp &amp;p)</argsstring>
        <name>cuda_get_device_property</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>cudaDeviceProp &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>obtains the device property </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="40" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="40" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a0e82b8a929e12349240276e34ec9f8c8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>cudaDeviceProp</type>
        <definition>cudaDeviceProp tf::cuda_get_device_property</definition>
        <argsstring>(int i)</argsstring>
        <name>cuda_get_device_property</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>obtains the device property </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="49" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="49" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aff8073c78daa741df76b530a0e602287" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_dump_device_property</definition>
        <argsstring>(std::ostream &amp;os, const cudaDeviceProp &amp;p)</argsstring>
        <name>cuda_dump_device_property</name>
        <param>
          <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const cudaDeviceProp &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>dumps the device property </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="60" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="60" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abf813f7ac4249d1b752d1b724f970deb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_threads_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_threads_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum threads per block on a device </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="102" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="102" bodyend="109"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1af8184bb128c446fe383315f3dc15acf6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_x_dim_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_x_dim_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum x-dimension per block on a device </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="114" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="114" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a9aba5f29135b9da29015c2a367ab1d70" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_y_dim_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_y_dim_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum y-dimension per block on a device </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="126" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="126" bodyend="133"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a5580f59e633625b2f344bbf477d17c2f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_z_dim_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_z_dim_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum z-dimension per block on a device </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="138" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="138" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a597579c8a9ab31244418e30a5aa74491" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_x_dim_per_grid</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_x_dim_per_grid</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum x-dimension per grid on a device </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="150" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="150" bodyend="157"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a91d5c1609a7542949dd56d08b7c4c645" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_y_dim_per_grid</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_y_dim_per_grid</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum y-dimension per grid on a device </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="162" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="162" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a0373e32a20c7fc90c4f0461ee41bb918" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_z_dim_per_grid</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_z_dim_per_grid</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum z-dimension per grid on a device </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="174" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="174" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aeca46ac171c4941a75aafddfe7546bfa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_shm_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_shm_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum shared memory size in bytes per block on a device </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="186" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="186" bodyend="193"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aea1b2af1073496f047d6fb9984cff4f1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_warp_size</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_warp_size</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the warp size on a device </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="198" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="198" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a1fb03793a6b8705026b80ef87599d4d5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_device_compute_capability_major</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_compute_capability_major</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the major number of compute capability of a device </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="210" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="210" bodyend="217"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a71f5177665f4f7e18984ccc57d625602" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_device_compute_capability_minor</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_compute_capability_minor</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the minor number of compute capability of a device </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="222" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="222" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ad389294b4d1c14219d8d098f796e27c5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tf::cuda_get_device_unified_addressing</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_unified_addressing</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries if the device supports unified addressing </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="234" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="234" bodyend="241"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a43ac57f0eca3aa83c04bec3c4da9ab82" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_driver_version</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_driver_version</name>
        <briefdescription>
<para>queries the latest CUDA version (1000 * major + 10 * minor) supported by the driver </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="250" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="250" bodyend="257"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a31258ad089c6f847c8cd636cd72d6949" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_runtime_version</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_runtime_version</name>
        <briefdescription>
<para>queries the CUDA <ref refid="classtf_1_1Runtime" kindref="compound">Runtime</ref> version (1000 * major + 10 * minor) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" line="262" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_device.hpp" bodystart="262" bodyend="268"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a1effcf929b7e488925f9e12d74c8c62b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_free_mem</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_free_mem</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the free memory (expensive call) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="19" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="19" bodyend="26"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a58bbc8d5d955582d6b5f7fdac51d010b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_total_mem</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_total_mem</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the total available memory (expensive call) </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="31" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="31" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a6f04fd3168c45eeb2dffb223e5c81e45" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* tf::cuda_malloc_device</definition>
        <argsstring>(size_t N, int d)</argsstring>
        <name>cuda_malloc_device</name>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>allocates memory on the given device for holding <computeroutput>N</computeroutput> elements of type <computeroutput>T</computeroutput> </para>        </briefdescription>
        <detaileddescription>
<para>The function calls <computeroutput>cudaMalloc</computeroutput> to allocate <computeroutput>N*sizeof(T)</computeroutput> bytes of memory on the given device <computeroutput>d</computeroutput> and returns a pointer to the starting address of the device memory. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="48" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="48" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ab9b68b8f4336f13b190d573969cb1cf7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* tf::cuda_malloc_device</definition>
        <argsstring>(size_t N)</argsstring>
        <name>cuda_malloc_device</name>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>allocates memory on the current device associated with the caller </para>        </briefdescription>
        <detaileddescription>
<para>The function calls malloc_device from the current device associated with the caller. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="65" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="65" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8eed05685b030fc44703213a4ef86f11" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* tf::cuda_malloc_shared</definition>
        <argsstring>(size_t N)</argsstring>
        <name>cuda_malloc_shared</name>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>allocates shared memory for holding <computeroutput>N</computeroutput> elements of type <computeroutput>T</computeroutput> </para>        </briefdescription>
        <detaileddescription>
<para>The function calls <computeroutput>cudaMallocManaged</computeroutput> to allocate <computeroutput>N*sizeof(T)</computeroutput> bytes of memory and returns a pointer to the starting address of the shared memory. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="81" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="81" bodyend="88"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ac7a8fe7456b888d6072ba94783c5003c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_free</definition>
        <argsstring>(T *ptr, int d)</argsstring>
        <name>cuda_free</name>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>frees memory on the GPU device </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>device pointer to memory to free </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d</parametername>
</parameternamelist>
<parameterdescription>
<para>device context identifier</para></parameterdescription>
</parameteritem>
</parameterlist>
This methods call <computeroutput>cudaFree</computeroutput> to free the memory space pointed to by <computeroutput>ptr</computeroutput> using the given device context. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="101" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="101" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ae174a3a49b91ef21554dac16806f0d72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_free</definition>
        <argsstring>(T *ptr)</argsstring>
        <name>cuda_free</name>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>frees memory on the GPU device </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>device pointer to memory to free</para></parameterdescription>
</parameteritem>
</parameterlist>
This methods call <computeroutput>cudaFree</computeroutput> to free the memory space pointed to by <computeroutput>ptr</computeroutput> using the current device context of the caller. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="116" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="116" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aa4266474b921f8ed7d9ec8071fded2a4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_memcpy_async</definition>
        <argsstring>(cudaStream_t stream, void *dst, const void *src, size_t count)</argsstring>
        <name>cuda_memcpy_async</name>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>copies data between host and device asynchronously through a stream </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>stream identifier </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>destination memory address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>source memory address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>size in bytes to copy</para></parameterdescription>
</parameteritem>
</parameterlist>
The method calls <computeroutput>cudaMemcpyAsync</computeroutput> with the given <computeroutput>stream</computeroutput> using <computeroutput>cudaMemcpyDefault</computeroutput> to infer the memory space of the source and the destination pointers. The memory areas may not overlap. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="132" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="132" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a6615554d2954e895755411ee444d9760" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_memset_async</definition>
        <argsstring>(cudaStream_t stream, void *devPtr, int value, size_t count)</argsstring>
        <name>cuda_memset_async</name>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>devPtr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>value</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>initializes or sets GPU memory to the given value byte by byte </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>stream identifier </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>devPtr</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to GPU mempry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>value to set for each byte of the specified memory </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>size in bytes to set</para></parameterdescription>
</parameteritem>
</parameterlist>
The method calls <computeroutput>cudaMemsetAsync</computeroutput> with the given <computeroutput>stream</computeroutput> to fill the first <computeroutput>count</computeroutput> bytes of the memory area pointed to by <computeroutput>devPtr</computeroutput> with the constant byte value <computeroutput>value</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" line="153" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_memory.hpp" bodystart="153" bodyend="160"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1af21fe1eaf680dbddc0503ef5d1a9a664" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr const char *</type>
        <definition>constexpr const char* tf::to_string</definition>
        <argsstring>(cudaTaskType type)</argsstring>
        <name>to_string</name>
        <param>
          <type><ref refid="namespacetf_1afebc56ae6d5765010d0dd13a5f04132e" kindref="member">cudaTaskType</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>convert a cuda_task type to a human-readable string </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_task.hpp" line="43" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_task.hpp" bodystart="43" bodyend="54"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a9cca69f61d792afb3ad501b703d795c1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
        <definition>std::ostream&amp; tf::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const cudaTask &amp;ct)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> &amp;</type>
          <declname>ct</declname>
        </param>
        <briefdescription>
<para>overload of ostream inserter operator for <ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_task.hpp" line="266" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_task.hpp" bodystart="266" bodyend="269"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a2ff1cf81426c856fc6db1f6ead47878f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_single_task</definition>
        <argsstring>(P &amp;&amp;p, C c)</argsstring>
        <name>cuda_single_task</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>C</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>runs a callable asynchronously using one kernel thread </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>closure type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>closure to run by one kernel thread</para></parameterdescription>
</parameteritem>
</parameterlist>
The function launches a single kernel thread to run the given callable through the stream in the execution policy object. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" line="69" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" bodystart="69" bodyend="73"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a7c449cec0b93503b8280d05add35e9f4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_for_each</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, C c)</argsstring>
        <name>cuda_for_each</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>C</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel iterations over a range of items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy object </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to each dereferenced iterator</para></parameterdescription>
</parameteritem>
</parameterlist>
This function is equivalent to a parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>itr<sp/>=<sp/>first;<sp/>itr<sp/>!=<sp/>last;<sp/>itr++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>c(*itr);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" line="97" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" bodystart="97" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a01ad7ce62fa6f42f2f2fbff3659b7884" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_for_each_index</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, I inc, C c)</argsstring>
        <name>cuda_for_each_index</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>I</type>
          <declname>inc</declname>
        </param>
        <param>
          <type>C</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel iterations over an index-based range of items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input index type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy object </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>index to the beginning of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>index to the end of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>inc</parametername>
</parameternamelist>
<parameterdescription>
<para>step size between successive iterations </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to each index</para></parameterdescription>
</parameteritem>
</parameterlist>
This function is equivalent to a parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>step<sp/>is<sp/>positive<sp/>[first,<sp/>last)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first;<sp/>i&lt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>c(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>step<sp/>is<sp/>negative<sp/>[first,<sp/>last)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first;<sp/>i&gt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>c(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" line="138" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" bodystart="138" bodyend="151"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a3075c7a1f4d08fefefb415b0e2ac58fb" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>__global__ void</type>
        <definition>__global__ void tf::cuda_single_task</definition>
        <argsstring>(C callable)</argsstring>
        <name>cuda_single_task</name>
        <param>
          <type>C</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" line="159" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/for_each.hpp" bodystart="159" bodyend="161"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a3ed764530620a419e3400e1f9ab6c956" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_transform</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, O output, C op)</argsstring>
        <name>cuda_transform</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel transforms over a range of items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to transform each item</para></parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*output++<sp/>=<sp/>op(*first++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/transform.hpp" line="84" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/transform.hpp" bodystart="84" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abdcb5b755f7ace2aa452541d5bf93b5f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I1</type>
          </param>
          <param>
            <type>typename I2</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_transform</definition>
        <argsstring>(P &amp;&amp;p, I1 first1, I1 last1, I2 first2, O output, C op)</argsstring>
        <name>cuda_transform</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>I1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>I2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel transforms over two ranges of items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I1</parametername>
</parameternamelist>
<parameterdescription>
<para>first input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I2</parametername>
</parameternamelist>
<parameterdescription>
<para>second input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the first range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the second range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to transform each pair of items</para></parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first1<sp/>!=<sp/>last1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*output++<sp/>=<sp/>op(*first1++,<sp/>*first2++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/transform.hpp" line="120" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/transform.hpp" bodystart="120" bodyend="131"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a1ca0bd68df882048e4b9b4d92efc3168" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>unsigned</type>
        <definition>unsigned tf::cuda_reduce_buffer_size</definition>
        <argsstring>(unsigned count)</argsstring>
        <name>cuda_reduce_buffer_size</name>
        <param>
          <type>unsigned</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>queries the buffer size in bytes needed to call reduce kernels </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to reduce</para></parameterdescription>
</parameteritem>
</parameterlist>
The function is used to allocate a buffer for calling <ref refid="namespacetf_1a8a872d2a0ac73a676713cb5be5aa688c" kindref="member">tf::cuda_reduce</ref>, <ref refid="namespacetf_1a492e8410db032a0273a99dd905486161" kindref="member">tf::cuda_uninitialized_reduce</ref>, <ref refid="namespacetf_1a4463d06240d608bc31d8b3546a851e4e" kindref="member">tf::cuda_transform_reduce</ref>, and <ref refid="namespacetf_1a747a41c0474fd34da370839b60ddc4ca" kindref="member">tf::cuda_transform_uninitialized_reduce</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" line="176" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" bodystart="176" bodyend="182"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8a872d2a0ac73a676713cb5be5aa688c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_reduce</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, T *res, O op, void *buf)</argsstring>
        <name>cuda_reduce</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>res</declname>
        </param>
        <param>
          <type>O</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel reduction over a range of items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the result </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to reduce elements </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result<sp/>=<sp/>op(*result,<sp/>*first++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" line="212" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" bodystart="212" bodyend="220"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a492e8410db032a0273a99dd905486161" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_uninitialized_reduce</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, T *res, O op, void *buf)</argsstring>
        <name>cuda_uninitialized_reduce</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>res</declname>
        </param>
        <param>
          <type>O</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel reduction over a range of items without an initial value </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the result </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to reduce elements </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="normal">*result<sp/>=<sp/>*first++;<sp/><sp/></highlight><highlight class="comment">//<sp/>no<sp/>initial<sp/>values<sp/>partitipcate<sp/>in<sp/>the<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result<sp/>=<sp/>op(*result,<sp/>*first++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" line="253" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" bodystart="253" bodyend="261"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a4463d06240d608bc31d8b3546a851e4e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_transform_reduce</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, T *res, O bop, U uop, void *buf)</argsstring>
        <name>cuda_transform_reduce</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>res</declname>
        </param>
        <param>
          <type>O</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>U</type>
          <declname>uop</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel reduction over a range of transformed items without an initial value </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the result </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to reduce elements </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to transform elements </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result<sp/>=<sp/>bop(*result,<sp/>uop(*first++));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" line="294" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" bodystart="294" bodyend="311"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a747a41c0474fd34da370839b60ddc4ca" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_transform_uninitialized_reduce</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, T *res, O bop, U uop, void *buf)</argsstring>
        <name>cuda_transform_uninitialized_reduce</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>res</declname>
        </param>
        <param>
          <type>O</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>U</type>
          <declname>uop</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous parallel reduction over a range of transformed items with an initial value </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>res</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the result </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to reduce elements </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to transform elements </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to the parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="normal">*result<sp/>=<sp/>uop(*first++);<sp/><sp/></highlight><highlight class="comment">//<sp/>no<sp/>initial<sp/>values<sp/>partitipcate<sp/>in<sp/>the<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result<sp/>=<sp/>bop(*result,<sp/>uop(*first++));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" line="346" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/reduce.hpp" bodystart="346" bodyend="364"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1afd7e7a0886352201cced5c55205f3229" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>unsigned</type>
        <definition>unsigned tf::cuda_scan_buffer_size</definition>
        <argsstring>(unsigned count)</argsstring>
        <name>cuda_scan_buffer_size</name>
        <param>
          <type>unsigned</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>queries the buffer size in bytes needed to call scan kernels </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to scan</para></parameterdescription>
</parameteritem>
</parameterlist>
The function is used to allocate a buffer for calling <ref refid="namespacetf_1a2e1b44c84a09e0a8495a611cb9a7ea40" kindref="member">tf::cuda_inclusive_scan</ref>, <ref refid="namespacetf_1aeb391c40120844318fd715b8c3a716bb" kindref="member">tf::cuda_exclusive_scan</ref>, <ref refid="namespacetf_1afa4aa760ddb6efbda1b9bab505ad5baf" kindref="member">tf::cuda_transform_inclusive_scan</ref>, and <ref refid="namespacetf_1a2e739895c1c73538967af060ca714366" kindref="member">tf::cuda_transform_exclusive_scan</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" line="340" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" bodystart="340" bodyend="348"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a2e1b44c84a09e0a8495a611cb9a7ea40" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_inclusive_scan</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, O output, C op, void *buf)</argsstring>
        <name>cuda_inclusive_scan</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous inclusive scan over a range of items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to scan </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" line="394" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" bodystart="394" bodyend="408"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1afa4aa760ddb6efbda1b9bab505ad5baf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_transform_inclusive_scan</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, O output, C bop, U uop, void *buf)</argsstring>
        <name>cuda_transform_inclusive_scan</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>U</type>
          <declname>uop</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous inclusive scan over a range of transformed items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to scan </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to transform each item before scan </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" line="461" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" bodystart="461" bodyend="479"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aeb391c40120844318fd715b8c3a716bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_exclusive_scan</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, O output, C op, void *buf)</argsstring>
        <name>cuda_exclusive_scan</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous exclusive scan over a range of items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to scan </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" line="526" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" bodystart="526" bodyend="540"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a2e739895c1c73538967af060ca714366" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_transform_exclusive_scan</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, O output, C bop, U uop, void *buf)</argsstring>
        <name>cuda_transform_exclusive_scan</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>O</type>
          <declname>output</declname>
        </param>
        <param>
          <type>C</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>U</type>
          <declname>uop</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous exclusive scan over a range of items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>output</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator to apply to scan </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator to apply to transform each item before scan </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" line="593" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/scan.hpp" bodystart="593" bodyend="611"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a3db5b8f718e7f6a6fa2da3a689bd8828" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>unsigned</type>
        <definition>unsigned tf::cuda_merge_buffer_size</definition>
        <argsstring>(unsigned a_count, unsigned b_count)</argsstring>
        <name>cuda_merge_buffer_size</name>
        <param>
          <type>unsigned</type>
          <declname>a_count</declname>
        </param>
        <param>
          <type>unsigned</type>
          <declname>b_count</declname>
        </param>
        <briefdescription>
<para>queries the buffer size in bytes needed to call merge kernels </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution polity type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a_count</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements in the first input array </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_count</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements in the second input array</para></parameterdescription>
</parameteritem>
</parameterlist>
The function is used to allocate a buffer for calling <ref refid="namespacetf_1a37ec481149c2f01669353033d75ed72a" kindref="member">tf::cuda_merge</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/merge.hpp" line="460" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/merge.hpp" bodystart="460" bodyend="464"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aa84d4c68d2cbe9f6efc4a1eb1a115458" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename a_keys_it</type>
          </param>
          <param>
            <type>typename a_vals_it</type>
          </param>
          <param>
            <type>typename b_keys_it</type>
          </param>
          <param>
            <type>typename b_vals_it</type>
          </param>
          <param>
            <type>typename c_keys_it</type>
          </param>
          <param>
            <type>typename c_vals_it</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_merge_by_key</definition>
        <argsstring>(P &amp;&amp;p, a_keys_it a_keys_first, a_keys_it a_keys_last, a_vals_it a_vals_first, b_keys_it b_keys_first, b_keys_it b_keys_last, b_vals_it b_vals_first, c_keys_it c_keys_first, c_vals_it c_vals_first, C comp, void *buf)</argsstring>
        <name>cuda_merge_by_key</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>a_keys_it</type>
          <declname>a_keys_first</declname>
        </param>
        <param>
          <type>a_keys_it</type>
          <declname>a_keys_last</declname>
        </param>
        <param>
          <type>a_vals_it</type>
          <declname>a_vals_first</declname>
        </param>
        <param>
          <type>b_keys_it</type>
          <declname>b_keys_first</declname>
        </param>
        <param>
          <type>b_keys_it</type>
          <declname>b_keys_last</declname>
        </param>
        <param>
          <type>b_vals_it</type>
          <declname>b_vals_first</declname>
        </param>
        <param>
          <type>c_keys_it</type>
          <declname>c_keys_first</declname>
        </param>
        <param>
          <type>c_vals_it</type>
          <declname>c_vals_first</declname>
        </param>
        <param>
          <type>C</type>
          <declname>comp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous key-value merge over a range of keys and values </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>first key iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_vals_it</parametername>
</parameternamelist>
<parameterdescription>
<para>first value iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>second key iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_vals_it</parametername>
</parameternamelist>
<parameterdescription>
<para>second value iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>output key iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_vals_it</parametername>
</parameternamelist>
<parameterdescription>
<para>output value iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the first key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_vals_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first value range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the second key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the second key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_vals_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the second value range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_vals_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output value range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
Performs a key-value merge that copies elements from <computeroutput>[a_keys_first, a_keys_last)</computeroutput> and <computeroutput>[b_keys_first, b_keys_last)</computeroutput> into a single range, <computeroutput>[c_keys_first, c_keys_last + (a_keys_last - a_keys_first) + (b_keys_last - b_keys_first))</computeroutput> such that the resulting range is in ascending key order.</para><para>At the same time, the merge copies elements from the two associated ranges <computeroutput>[a_vals_first + (a_keys_last - a_keys_first))</computeroutput> and <computeroutput>[b_vals_first + (b_keys_last - b_keys_first))</computeroutput> into a single range, <computeroutput>[c_vals_first, c_vals_first + (a_keys_last - a_keys_first) + (b_keys_last - b_keys_first))</computeroutput> such that the resulting range is in ascending order implied by each input element&apos;s associated key.</para><para>For example, assume:<itemizedlist>
<listitem><para><computeroutput>a_keys</computeroutput> = {8, 1};</para></listitem><listitem><para><computeroutput>a_vals</computeroutput> = {1, 2};</para></listitem><listitem><para><computeroutput>b_keys</computeroutput> = {3, 7};</para></listitem><listitem><para><computeroutput>b_vals</computeroutput> = {3, 4};</para></listitem></itemizedlist>
</para><para>After the merge, we have:<itemizedlist>
<listitem><para><computeroutput>c_keys</computeroutput> = {1, 3, 7, 8}</para></listitem><listitem><para><computeroutput>c_vals</computeroutput> = {2, 3, 4, 1} </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/merge.hpp" line="560" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/merge.hpp" bodystart="560" bodyend="581"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a37ec481149c2f01669353033d75ed72a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename a_keys_it</type>
          </param>
          <param>
            <type>typename b_keys_it</type>
          </param>
          <param>
            <type>typename c_keys_it</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_merge</definition>
        <argsstring>(P &amp;&amp;p, a_keys_it a_keys_first, a_keys_it a_keys_last, b_keys_it b_keys_first, b_keys_it b_keys_last, c_keys_it c_keys_first, C comp, void *buf)</argsstring>
        <name>cuda_merge</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>a_keys_it</type>
          <declname>a_keys_first</declname>
        </param>
        <param>
          <type>a_keys_it</type>
          <declname>a_keys_last</declname>
        </param>
        <param>
          <type>b_keys_it</type>
          <declname>b_keys_first</declname>
        </param>
        <param>
          <type>b_keys_it</type>
          <declname>b_keys_last</declname>
        </param>
        <param>
          <type>c_keys_it</type>
          <declname>c_keys_first</declname>
        </param>
        <param>
          <type>C</type>
          <declname>comp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous key-only merge over a range of keys </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>first key iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>second key iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_keys_it</parametername>
</parameternamelist>
<parameterdescription>
<para>output key iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>a_keys_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the first key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the second key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b_keys_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the second key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c_keys_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
This function is equivalent to <ref refid="namespacetf_1aa84d4c68d2cbe9f6efc4a1eb1a115458" kindref="member">tf::cuda_merge_by_key</ref> without values. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/merge.hpp" line="629" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/merge.hpp" bodystart="629" bodyend="644"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a9c69906a4dfd1e2d0cd7ed496d29dafd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename K</type>
          </param>
          <param>
            <type>typename V</type>
            <defval>cudaEmpty</defval>
          </param>
        </templateparamlist>
        <type>unsigned</type>
        <definition>unsigned tf::cuda_sort_buffer_size</definition>
        <argsstring>(unsigned count)</argsstring>
        <name>cuda_sort_buffer_size</name>
        <param>
          <type>unsigned</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>queries the buffer size in bytes needed to call sort kernels for the given number of elements </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>K</parametername>
</parameternamelist>
<parameterdescription>
<para>key type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>V</parametername>
</parameternamelist>
<parameterdescription>
<para>value type (default tf::cudaEmpty)</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>number of keys/values to sort</para></parameterdescription>
</parameteritem>
</parameterlist>
The function is used to allocate a buffer for calling <ref refid="namespacetf_1a06804cb1598e965febc7bd35fc0fbbb0" kindref="member">tf::cuda_sort</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" line="421" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" bodystart="421" bodyend="432"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a3461b9179221dd7230ce2a0e45156c7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename K_it</type>
          </param>
          <param>
            <type>typename V_it</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_sort_by_key</definition>
        <argsstring>(P &amp;&amp;p, K_it k_first, K_it k_last, V_it v_first, C comp, void *buf)</argsstring>
        <name>cuda_sort_by_key</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>K_it</type>
          <declname>k_first</declname>
        </param>
        <param>
          <type>K_it</type>
          <declname>k_last</declname>
        </param>
        <param>
          <type>V_it</type>
          <declname>v_first</declname>
        </param>
        <param>
          <type>C</type>
          <declname>comp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous key-value sort on a range of items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>K_it</parametername>
</parameternamelist>
<parameterdescription>
<para>key iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>V_it</parametername>
</parameternamelist>
<parameterdescription>
<para>value iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the value range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>binary comparator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
Sorts key-value elements in <computeroutput>[k_first, k_last)</computeroutput> and <computeroutput>[v_first, v_first + (k_last - k_first))</computeroutput> into ascending key order using the given comparator <computeroutput>comp</computeroutput>. If <computeroutput>i</computeroutput> and <computeroutput>j</computeroutput> are any two valid iterators in <computeroutput>[k_first, k_last)</computeroutput> such that <computeroutput>i</computeroutput> precedes <computeroutput>j</computeroutput>, and <computeroutput>p</computeroutput> and <computeroutput>q</computeroutput> are iterators in <computeroutput>[v_first, v_first + (k_last - k_first))</computeroutput> corresponding to <computeroutput>i</computeroutput> and <computeroutput>j</computeroutput> respectively, then <computeroutput>comp(*j, *i)</computeroutput> evaluates to <computeroutput>false</computeroutput>.</para><para>For example, assume:<itemizedlist>
<listitem><para><computeroutput>keys</computeroutput> are <computeroutput>{1, 4, 2, 8, 5, 7}</computeroutput></para></listitem><listitem><para><computeroutput>values</computeroutput> are <computeroutput>{&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;}</computeroutput></para></listitem></itemizedlist>
</para><para>After sort:<itemizedlist>
<listitem><para><computeroutput>keys</computeroutput> are <computeroutput>{1, 2, 4, 5, 7, 8}</computeroutput></para></listitem><listitem><para><computeroutput>values</computeroutput> are <computeroutput>{&apos;a&apos;, &apos;c&apos;, &apos;b&apos;, &apos;e&apos;, &apos;f&apos;, &apos;d&apos;}</computeroutput> </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" line="471" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" bodystart="471" bodyend="482"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a06804cb1598e965febc7bd35fc0fbbb0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename K_it</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_sort</definition>
        <argsstring>(P &amp;&amp;p, K_it k_first, K_it k_last, C comp, void *buf)</argsstring>
        <name>cuda_sort</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>K_it</type>
          <declname>k_first</declname>
        </param>
        <param>
          <type>K_it</type>
          <declname>k_last</declname>
        </param>
        <param>
          <type>C</type>
          <declname>comp</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>performs asynchronous key-only sort on a range of items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>K_it</parametername>
</parameternamelist>
<parameterdescription>
<para>key iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>k_last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the key range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>binary comparator </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the temporary buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
This method is equivalent to <ref refid="namespacetf_1a3461b9179221dd7230ce2a0e45156c7f" kindref="member">tf::cuda_sort_by_key</ref> without values. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" line="505" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/sort.hpp" bodystart="505" bodyend="507"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a5f9dabd7c5d0fa5166cf76d9fa5a038e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename U</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_find_if</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, unsigned *idx, U op)</argsstring>
        <name>cuda_find_if</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>unsigned *</type>
          <declname>idx</declname>
        </param>
        <param>
          <type>U</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>finds the index of the first element that satisfies the given criteria </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>U</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>idx</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the index of the found element </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator which returns <computeroutput>true</computeroutput> for the required element</para></parameterdescription>
</parameteritem>
</parameterlist>
The function launches kernels asynchronously to find the index <computeroutput>idx</computeroutput> of the first element in the range <computeroutput>[first, last)</computeroutput> such that <computeroutput>op(*(first+idx))</computeroutput> is true. This is equivalent to the parallel execution of the following loop:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/>idx<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(;<sp/>first<sp/>!=<sp/>last;<sp/>++first,<sp/>++idx)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(p(*first))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>idx;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>idx;</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/find.hpp" line="181" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/find.hpp" bodystart="181" bodyend="185"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abe3b31aaf686b491e9000f0867934713" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>unsigned</type>
        <definition>unsigned tf::cuda_min_element_buffer_size</definition>
        <argsstring>(unsigned count)</argsstring>
        <name>cuda_min_element_buffer_size</name>
        <param>
          <type>unsigned</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>queries the buffer size in bytes needed to call <ref refid="namespacetf_1a572c13198191c46765264f8afabe2e9f" kindref="member">tf::cuda_min_element</ref> </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to search</para></parameterdescription>
</parameteritem>
</parameterlist>
The function is used to decide the buffer size in bytes for calling <ref refid="namespacetf_1a572c13198191c46765264f8afabe2e9f" kindref="member">tf::cuda_min_element</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/find.hpp" line="249" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/find.hpp" bodystart="249" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a572c13198191c46765264f8afabe2e9f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_min_element</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, unsigned *idx, O op, void *buf)</argsstring>
        <name>cuda_min_element</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>unsigned *</type>
          <declname>idx</declname>
        </param>
        <param>
          <type>O</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>finds the index of the minimum element in a range </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy object </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>idx</parametername>
</parameternamelist>
<parameterdescription>
<para>solution index of the minimum element </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>comparison function object </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
The function launches kernels asynchronously to find the smallest element in the range <computeroutput>[first, last)</computeroutput> using the given comparator <computeroutput>op</computeroutput>. You need to provide a buffer that holds at least <ref refid="namespacetf_1abe3b31aaf686b491e9000f0867934713" kindref="member">tf::cuda_min_element_buffer_size</ref> bytes for internal use. The function is equivalent to a parallel execution of the following loop:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">if</highlight><highlight class="normal">(first<sp/>==<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>smallest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(++first;<sp/>first<sp/>!=<sp/>last;<sp/>++first)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(op(*first,<sp/>*smallest))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>smallest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="cpp/iterator/distance" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::distance</ref>(first,<sp/>smallest);</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/find.hpp" line="288" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/find.hpp" bodystart="288" bodyend="292"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a04965f210cc6447c7c38206a28c3c3d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>unsigned</type>
        <definition>unsigned tf::cuda_max_element_buffer_size</definition>
        <argsstring>(unsigned count)</argsstring>
        <name>cuda_max_element_buffer_size</name>
        <param>
          <type>unsigned</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>queries the buffer size in bytes needed to call <ref refid="namespacetf_1a3fc577fd0a8f127770bcf68bc56c073e" kindref="member">tf::cuda_max_element</ref> </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to search</para></parameterdescription>
</parameteritem>
</parameterlist>
The function is used to decide the buffer size in bytes for calling <ref refid="namespacetf_1a3fc577fd0a8f127770bcf68bc56c073e" kindref="member">tf::cuda_max_element</ref>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/find.hpp" line="374" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/find.hpp" bodystart="374" bodyend="376"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a3fc577fd0a8f127770bcf68bc56c073e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_max_element</definition>
        <argsstring>(P &amp;&amp;p, I first, I last, unsigned *idx, O op, void *buf)</argsstring>
        <name>cuda_max_element</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>p</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>unsigned *</type>
          <declname>idx</declname>
        </param>
        <param>
          <type>O</type>
          <declname>op</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>buf</declname>
        </param>
        <briefdescription>
<para>finds the index of the maximum element in a range </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p</parametername>
</parameternamelist>
<parameterdescription>
<para>execution policy object </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>idx</parametername>
</parameternamelist>
<parameterdescription>
<para>solution index of the maximum element </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>comparison function object </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>buf</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the buffer</para></parameterdescription>
</parameteritem>
</parameterlist>
The function launches kernels asynchronously to find the largest element in the range <computeroutput>[first, last)</computeroutput> using the given comparator <computeroutput>op</computeroutput>. You need to provide a buffer that holds at least <ref refid="namespacetf_1a04965f210cc6447c7c38206a28c3c3d4" kindref="member">tf::cuda_max_element_buffer_size</ref> bytes for internal use. The function is equivalent to a parallel execution of the following loop:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">if</highlight><highlight class="normal">(first<sp/>==<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>largest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(++first;<sp/>first<sp/>!=<sp/>last;<sp/>++first)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(op(*largest,<sp/>*first))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>largest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="cpp/iterator/distance" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::distance</ref>(first,<sp/>largest);</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/find.hpp" line="413" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/algorithm/find.hpp" bodystart="413" bodyend="417"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a160861c1c085842ecb0c56537199deaa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
        <definition>std::ostream&amp; tf::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const syclTask &amp;ct)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classtf_1_1syclTask" kindref="compound">syclTask</ref> &amp;</type>
          <declname>ct</declname>
        </param>
        <briefdescription>
<para>overload of ostream inserter operator for <ref refid="classtf_1_1syclTask" kindref="compound">syclTask</ref> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/sycl/sycl_task.hpp" line="201" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/sycl/sycl_task.hpp" bodystart="201" bodyend="204"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a30fa078dcf625e9eada5a95af1467588" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr const char *</type>
        <definition>constexpr const char* tf::version</definition>
        <argsstring>()</argsstring>
        <name>version</name>
        <briefdescription>
<para>queries the version information in a string format <computeroutput>major.minor.patch</computeroutput> </para>        </briefdescription>
        <detaileddescription>
<para>Release notes are available here: <ulink url="https://taskflow.github.io/taskflow/Releases.html">https://taskflow.github.io/taskflow/Releases.html</ulink> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/taskflow.hpp" line="59" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/taskflow.hpp" bodystart="59" bodyend="61"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>taskflow namespace </para>    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/twhuang/Code/taskflow/taskflow/utility/small_vector.hpp" line="27" column="1"/>
  </compounddef>
</doxygen>
